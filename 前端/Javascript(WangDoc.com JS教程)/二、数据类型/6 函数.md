# 函数

## 1. 概述

### 1.1 函数的声明

有三种声明函数的方法

1. function

   ```js
   function print(s) {
     console.log(s);
   }
   ```

   这叫做函数的声明（Function Declaration）

2. 函数表达式

   还可以采用变量赋值的写法

   ```js
   var print = function(s) {
     console.log(s);
   };
   ```

   采用函数表达式声明函数时，`function`命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效

   ```js
   var print = function x(){
     console.log(typeof x);
   };
   
   x
   // ReferenceError: x is not defined
   
   print()
   // function
   ```

   这个`x`只在函数体内部可用，指代函数表达式本身，其他地方都不可用

   这种写法的用处有两个

   + 一是可以在函数体内部调用自身
   + 二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）

   因此，下面的形式声明函数也非常常见：

   ```js
   var f = function f() {};
   ```

3. Function构造函数

   ```js
   var add = new Function(
     'x',
     'y',
     'return x + y'
   );
   
   // 等同于
   function add(x, y) {
     return x + y;
   }
   ```

   `Function`构造函数接受三个参数，除了最后一个参数是`add`函数的“函数体”，其他参数都是`add`函数的参数

   可以传递任意数量的参数给`Function`构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体

   > [!Warning]
   >
   > 非常不直观，几乎无人使用

### 1.2 函数的重复声明

如果同一个函数被多次声明，后面的声明就会覆盖前面的声明，而且，由于函数名的提升（参见下文），前一次声明在任何时候都是无效的

### 1.3 圆括号运算符，return 语句和递归

调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数，函数名后面紧跟一对圆括号，就会调用这个函数

函数体内部的`return`语句，表示返回

`return`语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回`undefined`

函数可以调用自身，这就是递归（recursion）。下面就是通过递归，计算斐波那契数列的代码

```js
function fib(num) {
  if (num === 0) return 0;
  if (num === 1) return 1;
  return fib(num - 2) + fib(num - 1);
}

fib(6) // 8
```

上面代码中，`fib`函数内部又调用了`fib`，计算得到斐波那契数列的第6个元素是8

### 1.4 第一等公民

JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。

凡是可以使用值的地方，就能使用函数

+ 把函数赋值给变量和对象的属性
+ 当作参数传入其他函数
+ 作为函数的结果返回

函数只是一个可以执行的值，此外并无特殊之处

由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民

### 1.5 函数名的提升

JavaScript 引擎将函数名视同变量名，所以采用`function`命令声明函数时，整个函数会像变量声明一样，被提升到代码头部

所以，下面的代码不会报错

```js
f();

function f() {}
```

但是，如果采用赋值语句定义函数，JavaScript 就会报错

```js
f();
var f = function (){};
// TypeError: undefined is not a function
```

上面的代码等同于下面的形式

```js
var f;
f();
f = function () {};
```

上面代码第二行，调用`f`的时候，`f`只是被声明了，还没有被赋值，等于`undefined`，所以会报错

注意，如果像下面例子那样，采用`function`命令和`var`赋值语句声明同一个函数，由于存在函数提升，最后会采用`var`赋值语句的定义

```js
var f = function () {
  console.log('1');
}

function f() {
  console.log('2');
}

f() // 1
```

上面例子中，表面上后面声明的函数`f`，应该覆盖前面的`var`赋值语句，但是由于存在函数提升，实际上正好反过来

---

## 2. 函数的属性和方法

### 2.1 name属性

`name`属性返回函数的名字

```js
function f1() {}
f1.name // "f1"
```

如果是通过变量赋值定义的函数，那么`name`属性返回变量名

```js
var f2 = function () {};
f2.name // "f2"
```

但是，上面这种情况，只有在变量的值是一个匿名函数时才是如此。如果变量的值是一个具名函数，那么`name`属性返回`function`关键字之后的那个函数名

```js
var f3 = function myName() {};
f3.name // 'myName'
```

上面代码中，`f3.name`返回函数表达式的名字。注意，真正的函数名还是`f3`，而`myName`这个名字只在函数体内部可用

`name`属性的一个用处，就是获取参数函数的名字

```js
var myFunc = function () {};

function test(f) {
  console.log(f.name);
}

test(myFunc) // myFunc
```

上面代码中，函数`test`内部通过`name`属性，就可以知道传入的参数是什么函数

### 2.2 length属性

函数的`length`属性返回函数预期传入的参数个数，即函数定义之中的参数个数

```js
function f(a, b) {}
f.length // 2
```

上面代码定义了空函数`f`，它的`length`属性就是定义时的参数个数。不管调用时输入了多少个参数，`length`属性始终等于2

`length`属性提供了一种机制，判断定义时和调用时参数的差异，以便实现**面向对象编程的“方法重载”（overload）**

### 2.3 toString()

函数的`toString()`方法返回一个字符串，内容是函数的源码

对于那些原生的函数，`toString()`方法返回`function (){[native code]}`

```JS
Math.sqrt.toString()
// "function sqrt() { [native code] }"
```

上面代码中，`Math.sqrt()`是 JavaScript 引擎提供的原生函数，`toString()`方法就返回原生代码的提示

函数内部的注释也可以返回

```js
function f() {/*
  这是一个
  多行注释
*/}

f.toString()
// "function f(){/*
//   这是一个
//   多行注释
// */}"
```

利用这一点，可以变相实现多行字符串

```js
var multiline = function (fn) {
  var arr = fn.toString().split('\n');
  return arr.slice(1, arr.length - 1).join('\n');
};

function f() {/*
  这是一个
  多行注释	
*/}

multiline(f);
// " 这是一个
//   多行注释"
```